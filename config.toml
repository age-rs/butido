# repository of package definitions
repository = "/tmp/path"

# The position of the release binaries
#
# butido checks this location for packages when installing dependencies
#
#
# # Note
#
# Interpolation of variables (ones that are passed on the CLI for
# the build), is supported for this variable.
# This way you can write
#
# ```
# releases = "/storage/releases/${IMAGE}/"
# ```
#
# for example.
#
releases = "/tmp/releases"

# The position of the staging binaries
# butido rolls a dice for each submitted build and generates a
# per-process-staging directory here to store intermediate builds.
#
#
# # Note
#
# Interpolation of variables (ones that are passed on the CLI for
# the build), is supported for this variable.
# This way you can write
#
# ```
# staging = "/storage/staging/${IMAGE}/${SOME_ENV_VAR}"
# ```
#
# for example.
#
#
# # Warning
#
# It is the task of the user to move packages from herre to the "releases"
# folder.
#
staging  = "/tmp/staging"

# ####
#
# Log database configuration
#
# ####

# The database to use
#
# Can be overridden via environment vairbale BUTIDO_DATABASE_URI or set via CLI.
database_host     = "localhost"
database_port     = 5432
database_user     = "pgdev"
database_password = "password"
database_name     = "butido"

# Phases which can be configured in the packages

# This also defines the _order_ in which the phases are executed
# Each phase gets a pre_ and a post_ phase added automatically.
# So for [ "foo", "bar" ], the phases are executed in this order:
#   pre_foo
#   foo
#   post_foo
#   pre_bar
#   bar
#   post_bar
#
# Phases which are not listed here are not executed at all.
available_phases = [ "unpack", "patch", "configure", "build", "fixup", "pack" ]

[docker]
# Images which can be used to build
# images not listed here are automatically rejected
images = [ "debian:bullseye" ]

#
# Verify whether the requested images are present
#
# This setting is twofold:
# First, it checks whether the image requested on the commandline (when
# building) is actually in the whitelist (`docker.images` setting in the
# configuration file).
# Second, it checks that every used endpoint actually has the requested image
# present.
# This check is done when setting up the connection to the endpoints, so this
# will fail _before_ any actual building starts.
#
verify_images_present = true

# List of docker endpoints
[[docker.endpoints]]
name          = "testhostname"
uri           = "http://0.0.0.0:8095"
endpoint_type = "http"
speed         = 1
maxjobs       = 1


[containers]
# environment variables which are allowed during container start
# This way, errors (typos) when passing environment to a build can be prevented
allowed_env = [ "PATH" ]

